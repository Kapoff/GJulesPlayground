<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Track Meal</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <button id="globalShutdownBtn" class="global-shutdown-button" title="Shutdown Server">
        &times; <!-- This is the 'X' symbol -->
        <span class="tooltip-text">Shutdown Server</span>
    </button>

    <div class="container">
        <header>
            <h1>Track Your Meal</h1>
            <nav>
                <a href="{{ url_for('index') }}" class="nav-link">Home</a>
                <a href="{{ url_for('add_ingredient_page') }}" class="nav-link">Add Ingredient</a>
            </nav>
        </header>

        <section id="mealCompositionSection">
            <h2>Compose Your Meal</h2>
            <div class="form-group">
                <label for="mealName">Meal Name:</label>
                <input type="text" id="mealName" name="mealName" value="My Custom Meal">
            </div>

            <div class="ingredient-selector">
                <div class="form-group">
                    <label for="ingredientSearch">Select Ingredient:</label>
                    <input type="text" id="ingredientSearch" placeholder="Search ingredients...">
                    <select id="ingredientSelect" name="ingredientSelect" size="5"></select>
                </div>
                <div class="form-group">
                    <label for="ingredientWeight">Weight (grams):</label>
                    <input type="number" id="ingredientWeight" name="ingredientWeight" min="0" step="0.1" placeholder="e.g., 150">
                </div>
                <button id="addIngredientToMealBtn" class="button">Add to Meal</button>
            </div>
            <div id="mealIngredientStatus" class="status-message" style="margin-top: 10px;"></div>
        </section>

        <section id="currentMealSection">
            <h2>Current Meal Ingredients</h2>
            <ul id="currentMealList">
                <!-- Ingredients will be listed here by JavaScript -->
            </ul>
            <!-- Checkbox removed -->
            <button id="saveAndLogMealBtn" class="button primary-action" disabled style="margin-top: 20px;">Save and Log Meal</button>
        </section>

        <section id="nutritionResultsSection" style="display:none;">
            <h2>Nutritional Information for <span id="resultMealName"></span></h2>
            <div id="nutritionStatus" class="status-message"></div>
            <h3>Total Meal Nutrition:</h3>
            <table id="totalNutritionTable">
                <thead>
                    <tr>
                        <th>Nutrient</th>
                        <th>Amount</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Populated by JavaScript -->
                </tbody>
            </table>

            <h3>Nutrition per 100g of Meal:</h3>
            <table id="per100gNutritionTable">
                <thead>
                    <tr>
                        <th>Nutrient</th>
                        <th>Amount</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Populated by JavaScript -->
                </tbody>
            </table>
        </section>

        <section id="mealHistorySectionOnTrackPage"> <!-- Different ID to avoid conflict if JS is not perfectly isolated -->
            <h2>Meal History</h2>
            <ul id="mealHistoryListOnTrackPage" class="meal-history-list-container">
                <li>Loading meal history...</li>
            </ul>
            <div id="mealHistoryStatusOnTrackPage" class="status-message" style="margin-top:10px;"></div>
        </section>
    </div>

    <!-- Modal for Meal Details (copied from index.html, ensure IDs are unique or handled if both pages load same JS) -->
    <!-- To be safe, let's use unique IDs for the modal on this page -->
    <div id="mealDetailModalTrackPage" class="modal">
        <div class="modal-content">
            <span class="modal-close-btn" onclick="closeMealDetailModalTrackPage()">&times;</span>
            <h2 id="modalMealNameTrackPage">Meal Details</h2>
            <div id="modalMealTimestampTrackPage" style="font-size: 0.9em; color: #555; margin-bottom: 15px;"></div>
            <div class="modal-body">
                <h3>Ingredients Used:</h3>
                <ul id="modalIngredientsListTrackPage"></ul>
                <h3>Total Nutrition:</h3>
                <ul id="modalTotalNutritionTrackPage"></ul>
                <h3>Nutrition per 100g:</h3>
                <ul id="modalPer100gNutritionTrackPage"></ul>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements for Meal Tracking
        const mealNameInput = document.getElementById('mealName');
        const ingredientSearch = document.getElementById('ingredientSearch');
        const ingredientSelect = document.getElementById('ingredientSelect');
        const ingredientWeightInput = document.getElementById('ingredientWeight');
        const addIngredientToMealBtn = document.getElementById('addIngredientToMealBtn');
        const currentMealList = document.getElementById('currentMealList');
        const saveAndLogMealBtn = document.getElementById('saveAndLogMealBtn'); // Renamed variable
        const nutritionResultsSection = document.getElementById('nutritionResultsSection');
        const resultMealName = document.getElementById('resultMealName');
        const totalNutritionTableBody = document.getElementById('totalNutritionTable').getElementsByTagName('tbody')[0];
        const per100gNutritionTableBody = document.getElementById('per100gNutritionTable').getElementsByTagName('tbody')[0];
        const mealIngredientStatus = document.getElementById('mealIngredientStatus');
        const nutritionStatus = document.getElementById('nutritionStatus');

        let availableIngredients = [];
        // Structure for currentMeal items: { name: string, weight: float, originalData: object, calculatedMacros?: object }
        let currentMeal = [];

        function calculateSingleIngredientMacros(ingredientBaseData, weight) {
            if (!ingredientBaseData || typeof weight !== 'number' || weight <= 0) {
                return null;
            }
            // Assuming ingredientBaseData contains nutritional values per 100g
            const factor = weight / 100.0;
            return {
                calories: ingredientBaseData.calories * factor,
                protein_g: ingredientBaseData.protein * factor,
                carbs_g: ingredientBaseData.carbs * factor,
                fat_g: ingredientBaseData.fat * factor
            };
        }

        async function fetchIngredients() {
            try {
                const response = await fetch('/api/get_ingredients');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                availableIngredients = await response.json();
                populateIngredientSelect(availableIngredients);
            } catch (error) {
                console.error('Error fetching ingredients:', error);
                mealIngredientStatus.textContent = 'Error loading ingredients. Please try refreshing.';
                mealIngredientStatus.className = 'status-message error';
            }
        }

        function populateIngredientSelect(ingredients) {
            ingredientSelect.innerHTML = ''; // Clear existing options
            ingredients.forEach(ing => {
                const option = document.createElement('option');
                option.value = ing.name;
                option.textContent = ing.name; // Display only the name

                // Create tooltip content
                const tooltipText = `Calories: ${ing.calories.toFixed(1)} kcal\nProtein: ${ing.protein.toFixed(1)} g\nCarbs: ${ing.carbs.toFixed(1)} g\nFat: ${ing.fat.toFixed(1)} g\n(per 100g)`;
                option.title = tooltipText; // Use the native title attribute for simple tooltips

                ingredientSelect.appendChild(option);
            });
        }

        ingredientSearch.addEventListener('input', () => {
            const searchTerm = ingredientSearch.value.toLowerCase();
            const filteredIngredients = availableIngredients.filter(ing => ing.name.toLowerCase().includes(searchTerm));
            populateIngredientSelect(filteredIngredients);
        });

        addIngredientToMealBtn.addEventListener('click', () => {
            const selectedOption = ingredientSelect.options[ingredientSelect.selectedIndex];
            const weight = parseFloat(ingredientWeightInput.value);

            mealIngredientStatus.textContent = '';
            mealIngredientStatus.className = 'status-message';

            if (!selectedOption) {
                mealIngredientStatus.textContent = 'Please select an ingredient.';
                mealIngredientStatus.className = 'status-message error';
                return;
            }
            if (isNaN(weight) || weight <= 0) {
                mealIngredientStatus.textContent = 'Please enter a valid positive weight.';
                mealIngredientStatus.className = 'status-message error';
                return;
            }

            const ingredientName = selectedOption.value;
            const ingredientData = availableIngredients.find(ing => ing.name === ingredientName);

            if (ingredientData) {
                const newItem = {
                    name: ingredientName,
                    weight: weight,
                    originalData: ingredientData
                };
                newItem.calculatedMacros = calculateSingleIngredientMacros(newItem.originalData, newItem.weight);
                currentMeal.push(newItem);

                renderCurrentMeal(); // This will now display the item with its calculated macros
                updateClientSideTotalPreview(); // Update total preview
                ingredientWeightInput.value = ''; // Clear weight input
                saveAndLogMealBtn.disabled = false; // Use renamed variable
                mealIngredientStatus.textContent = `${ingredientName} added to meal.`;
                mealIngredientStatus.className = 'status-message success';
                 setTimeout(() => { mealIngredientStatus.textContent = ''; mealIngredientStatus.className = 'status-message';}, 3000);
            } else {
                mealIngredientStatus.textContent = 'Selected ingredient not found in available list.';
                mealIngredientStatus.className = 'status-message error';
            }
        });

        function renderCurrentMeal() {
            currentMealList.innerHTML = ''; // Clear existing list
            if (currentMeal.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No ingredients added yet.';
                currentMealList.appendChild(li);
                saveAndLogMealBtn.disabled = true; // Use renamed variable
                return;
            }
            currentMeal.forEach((item, index) => {
                const li = document.createElement('li');
                li.classList.add('meal-item-row'); // This will be the grid container

                // 1. Ingredient Name
                const nameSpan = document.createElement('span');
                nameSpan.classList.add('meal-item-name');
                nameSpan.textContent = item.name;
                nameSpan.title = item.name; // For full name tooltip on hover
                li.appendChild(nameSpan);

                // 2. Weight Input Group (Input + Unit)
                const weightGroup = document.createElement('div');
                weightGroup.classList.add('meal-item-weight-group');

                const weightInput = document.createElement('input');
                weightInput.type = 'number';
                weightInput.value = item.weight;
                weightInput.min = "0.1";
                weightInput.step = "0.1";
                weightInput.classList.add('editable-weight-input');
                weightInput.dataset.index = index;
                weightInput.addEventListener('change', (event) => handleWeightChange(event, index));
                weightGroup.appendChild(weightInput);

                const unitSpan = document.createElement('span');
                unitSpan.classList.add('meal-item-unit');
                unitSpan.textContent = "g";
                weightGroup.appendChild(unitSpan);
                li.appendChild(weightGroup);

                // 3. Kcal
                const kcalSpan = document.createElement('span');
                kcalSpan.classList.add('meal-item-macro', 'macro-kcal');
                li.appendChild(kcalSpan);

                // 4. Protein
                const protSpan = document.createElement('span');
                protSpan.classList.add('meal-item-macro', 'macro-prot');
                li.appendChild(protSpan);

                // 5. Carbs
                const carbSpan = document.createElement('span');
                carbSpan.classList.add('meal-item-macro', 'macro-carb');
                li.appendChild(carbSpan);

                // 6. Fat
                const fatSpan = document.createElement('span');
                fatSpan.classList.add('meal-item-macro', 'macro-fat');
                li.appendChild(fatSpan);

                // Populate macros if they exist
                // The updateMacrosDisplay function will now need to find these individual spans
                if (item.calculatedMacros) {
                    updateMacrosDisplay(li, item.calculatedMacros); // Pass the whole li to find spans within
                } else {
                    updateMacrosDisplay(li, null); // Clear them if no data
                }

                // 7. Remove Button
                const removeBtn = document.createElement('button');
                removeBtn.classList.add('meal-item-remove-btn'); // Keep existing class for basic styling if any
                removeBtn.innerHTML = '&times;'; // 'X' symbol
                removeBtn.title = 'Remove ingredient';
                removeBtn.onclick = () => {
                    currentMeal.splice(index, 1);
                    renderCurrentMeal();
                    if (currentMeal.length === 0) saveAndLogMealBtn.disabled = true; // Use renamed variable
                     // If nutrition results are visible, prompt for recalculation
                    if (nutritionResultsSection.style.display !== 'none') {
                        nutritionStatus.textContent = 'Meal composition changed (item removed). Please recalculate.';
                        nutritionStatus.className = 'status-message info';
                        // Clear or hide old overall results table
                        // totalNutritionTableBody.innerHTML = '';
                        // per100gNutritionTableBody.innerHTML = '';
                    }
                    updateClientSideTotalPreview(); // Update total preview after removing an item
                };
                li.appendChild(removeBtn);
                currentMealList.appendChild(li);
            });
        }

        function handleWeightChange(event, index) {
            const newWeight = parseFloat(event.target.value);
            if (!isNaN(newWeight) && newWeight > 0) {
                currentMeal[index].weight = newWeight;
                // Recalculate and update macros for this specific item
                currentMeal[index].calculatedMacros = calculateSingleIngredientMacros(currentMeal[index].originalData, newWeight);

                // Update the display for this specific item's macros by finding the li
                const listItem = document.querySelector(`#currentMealList .meal-item-row:nth-child(${index + 1})`);
                if (listItem) { // Check if listItem is found
                    updateMacrosDisplay(listItem, currentMeal[index].calculatedMacros);
                } else {
                    // Fallback to re-rendering the whole list if direct update fails, though less ideal
                    console.warn(`Could not find list item for index ${index} to update macros directly. Re-rendering list.`);
                    renderCurrentMeal();
                }

                // If overall meal results were visible, they are now potentially stale
                if (nutritionResultsSection.style.display !== 'none') {
                    nutritionStatus.textContent = 'Meal composition changed. Please recalculate overall totals.';
                    nutritionStatus.className = 'status-message info';
                    // Clear overall totals tables as they are definitely outdated
                    // totalNutritionTableBody.innerHTML = '<tr><td colspan="2"><em>Totals outdated due to weight change. Recalculate meal.</em></td></tr>';
                    // per100gNutritionTableBody.innerHTML = '<tr><td colspan="2"><em>Totals outdated due to weight change. Recalculate meal.</em></td></tr>';
                    // Instead of clearing, let's just update the preview
                }
                updateClientSideTotalPreview(); // Update total preview after weight change
            } else {
                event.target.value = currentMeal[index].weight; // Reset to old value if input is invalid
                mealIngredientStatus.textContent = 'Invalid weight. Please enter a positive number.';
                mealIngredientStatus.className = 'status-message error';
                setTimeout(() => { mealIngredientStatus.textContent = ''; mealIngredientStatus.className = 'status-message'; }, 3000);
            }
        }

        // Update this function to work with the new flat structure within the li
        function updateMacrosDisplay(listItem, macros) { // listItem is the <li> element
            const kcalSpan = listItem.querySelector('.macro-kcal');
            const protSpan = listItem.querySelector('.macro-prot');
            const carbSpan = listItem.querySelector('.macro-carb');
            const fatSpan = listItem.querySelector('.macro-fat');

            if (macros) {
                kcalSpan.textContent = `kcal: ${macros.calories.toFixed(0)}`;
                protSpan.textContent = `Prot.: ${macros.protein_g.toFixed(1)}g`;
                carbSpan.textContent = `Carb.: ${macros.carbs_g.toFixed(1)}g`;
                fatSpan.textContent = `Fat: ${macros.fat_g.toFixed(1)}g`;
            } else {
                // Clear display
                if(kcalSpan) kcalSpan.textContent = '';
                if(protSpan) protSpan.textContent = '';
                if(carbSpan) carbSpan.textContent = '';
                if(fatSpan) fatSpan.textContent = '';
            }
        }

        function updateClientSideTotalPreview() {
            if (currentMeal.length === 0) {
                nutritionResultsSection.style.display = 'none';
                totalNutritionTableBody.innerHTML = '';
                per100gNutritionTableBody.innerHTML = '';
                if (resultMealName) resultMealName.textContent = mealNameInput.value || 'Your Meal';
                if (nutritionStatus) nutritionStatus.textContent = 'Add ingredients to see totals.';
                return;
            }

            let totalWeight = 0;
            let totalCalories = 0;
            let totalProtein = 0;
            let totalCarbs = 0;
            let totalFat = 0;

            currentMeal.forEach(item => {
                if (item.calculatedMacros && typeof item.weight === 'number') {
                    totalWeight += item.weight;
                    totalCalories += item.calculatedMacros.calories;
                    totalProtein += item.calculatedMacros.protein_g;
                    totalCarbs += item.calculatedMacros.carbs_g;
                    totalFat += item.calculatedMacros.fat_g;
                }
            });

            const previewTotalNutrition = {
                total_weight_g: totalWeight,
                total_calories: totalCalories,
                total_protein_g: totalProtein,
                total_carbs_g: totalCarbs,
                total_fat_g: totalFat
            };

            let previewPer100g = { calories_per_100g: null, protein_per_100g: null, carbs_per_100g: null, fat_per_100g: null };
            if (totalWeight > 0) {
                const factor = 100.0 / totalWeight;
                previewPer100g = {
                    calories_per_100g: totalCalories * factor,
                    protein_per_100g: totalProtein * factor,
                    carbs_per_100g: totalCarbs * factor,
                    fat_per_100g: totalFat * factor
                };
            }

            // Use the existing displayNutritionResults structure but with client data
            // Or simplify by directly updating the table (populateTable function is generic)
            if (resultMealName) resultMealName.textContent = mealNameInput.value || 'Your Meal (Preview)';

            totalNutritionTableBody.innerHTML = ''; // Clear previous results
            populateTable(totalNutritionTableBody, [
                { nutrient: 'Total Weight', amount: `${previewTotalNutrition.total_weight_g.toFixed(1)}g` },
                { nutrient: 'Total Calories', amount: `${previewTotalNutrition.total_calories.toFixed(1)} kcal` },
                { nutrient: 'Total Protein', amount: `${previewTotalNutrition.total_protein_g.toFixed(1)}g` },
                { nutrient: 'Total Carbs', amount: `${previewTotalNutrition.total_carbs_g.toFixed(1)}g` },
                { nutrient: 'Total Fat', amount: `${previewTotalNutrition.total_fat_g.toFixed(1)}g` }
            ]);

            per100gNutritionTableBody.innerHTML = ''; // Clear previous results
            if (previewPer100g.calories_per_100g !== null) {
                populateTable(per100gNutritionTableBody, [
                    { nutrient: 'Calories per 100g', amount: `${previewPer100g.calories_per_100g.toFixed(1)} kcal` },
                    { nutrient: 'Protein per 100g', amount: `${previewPer100g.protein_per_100g.toFixed(1)}g` },
                    { nutrient: 'Carbs per 100g', amount: `${previewPer100g.carbs_per_100g.toFixed(1)}g` },
                    { nutrient: 'Fat per 100g', amount: `${previewPer100g.fat_per_100g.toFixed(1)}g` }
                ]);
            } else {
                 const row = per100gNutritionTableBody.insertRow();
                 const cell = row.insertCell();
                 cell.colSpan = 2;
                 cell.textContent = 'N/A (meal weight is zero)';
            }
            nutritionResultsSection.style.display = 'block';
            if (nutritionStatus) nutritionStatus.textContent = 'Values are updated on the fly - Press the Save button to add your meal to the log';
            if (nutritionStatus) nutritionStatus.className = 'status-message info';
        }


        saveAndLogMealBtn.addEventListener('click', async () => { // Use renamed variable
            if (currentMeal.length === 0) {
                nutritionStatus.textContent = 'Cannot save an empty meal.'; // Adjusted message
                nutritionStatus.className = 'status-message error';
                nutritionResultsSection.style.display = 'block';
                return;
            }

            // const saveToHistoryCheckbox = document.getElementById('saveMealToHistoryCheckbox'); // Checkbox removed
            const mealPayload = {
                name: mealNameInput.value || 'My Custom Meal',
                ingredients: currentMeal.map(item => ({ name: item.name, weight: item.weight })),
                save_meal: true // Always true now
            };

            nutritionStatus.textContent = 'Calculating...';
            nutritionStatus.className = 'status-message info';
            nutritionResultsSection.style.display = 'block';


            try {
                const response = await fetch('/api/calculate_meal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(mealPayload)
                });

                const result = await response.json();
                nutritionStatus.textContent = ''; // Clear calculating message

                if (response.ok && result.success) {
                    displayNutritionResults(result.meal_name, result.total_nutrition, result.nutrition_per_100g, result.ingredients_list);
                    if (mealPayload.save_meal) { // Check if the meal was intended to be saved
                        fetchMealHistoryForTrackPage(); // Refresh history list on this page
                    }
                } else {
                    nutritionStatus.textContent = result.message || 'Error calculating nutrition.';
                    nutritionStatus.className = 'status-message error';
                    totalNutritionTableBody.innerHTML = '';
                    per100gNutritionTableBody.innerHTML = '';
                }
            } catch (error) {
                console.error('Error calculating nutrition:', error);
                nutritionStatus.textContent = 'An unexpected error occurred. Please try again.';
                nutritionStatus.className = 'status-message error';
                totalNutritionTableBody.innerHTML = '';
                per100gNutritionTableBody.innerHTML = '';
            }
        });

        function displayNutritionResults(name, totalNutrition, per100gNutrition, ingredientsList) {
            resultMealName.textContent = name;

            // Store calculated macros for each ingredient back into the currentMeal array
            // ingredientsList comes from the server and contains calculated values per item
            ingredientsList.forEach((calculatedItem, index) => {
                if (currentMeal[index] && currentMeal[index].name === calculatedItem.name) {
                    currentMeal[index].calculatedMacros = {
                        calories: calculatedItem.calories,
                        protein_g: calculatedItem.protein_g,
                        carbs_g: calculatedItem.carbs_g,
                        fat_g: calculatedItem.fat_g
                    };
                }
            });

            // Re-render the current meal list to show these new macros
            renderCurrentMeal();

            totalNutritionTableBody.innerHTML = ''; // Clear previous results
            populateTable(totalNutritionTableBody, [
                { nutrient: 'Total Weight', amount: `${totalNutrition.total_weight_g.toFixed(1)}g` },
                { nutrient: 'Total Calories', amount: `${totalNutrition.total_calories.toFixed(1)} kcal` },
                { nutrient: 'Total Protein', amount: `${totalNutrition.total_protein_g.toFixed(1)}g` },
                { nutrient: 'Total Carbs', amount: `${totalNutrition.total_carbs_g.toFixed(1)}g` },
                { nutrient: 'Total Fat', amount: `${totalNutrition.total_fat_g.toFixed(1)}g` }
            ]);

            per100gNutritionTableBody.innerHTML = ''; // Clear previous results
            if (per100gNutrition.calories_per_100g !== null) {
                populateTable(per100gNutritionTableBody, [
                    { nutrient: 'Calories per 100g', amount: `${per100gNutrition.calories_per_100g.toFixed(1)} kcal` },
                    { nutrient: 'Protein per 100g', amount: `${per100gNutrition.protein_per_100g.toFixed(1)}g` },
                    { nutrient: 'Carbs per 100g', amount: `${per100gNutrition.carbs_per_100g.toFixed(1)}g` },
                    { nutrient: 'Fat per 100g', amount: `${per100gNutrition.fat_per_100g.toFixed(1)}g` }
                ]);
            } else {
                 const row = per100gNutritionTableBody.insertRow();
                 const cell = row.insertCell();
                 cell.colSpan = 2;
                 cell.textContent = 'N/A (meal weight is zero)';
            }
            nutritionResultsSection.style.display = 'block';
            nutritionStatus.textContent = 'Calculation successful!';
            nutritionStatus.className = 'status-message success';
        }

        function populateTable(tbody, data) {
            data.forEach(item => {
                const row = tbody.insertRow();
                const cellNutrient = row.insertCell();
                const cellAmount = row.insertCell();
                cellNutrient.textContent = item.nutrient;
                cellAmount.textContent = item.amount;
            });
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            fetchIngredients();
            renderCurrentMeal();
            fetchMealHistoryForTrackPage();

            // Check for meal template from localStorage
            const reuseDataString = localStorage.getItem('reuseMealTemplate');
            if (reuseDataString) {
                try {
                    const reuseData = JSON.parse(reuseDataString);
                    mealNameInput.value = reuseData.name || 'My Custom Meal (Reused)';

                    currentMeal = []; // Clear any existing items
                    if (reuseData.ingredients && Array.isArray(reuseData.ingredients)) {
                        reuseData.ingredients.forEach(ingDetails => {
                            const ingredientBase = availableIngredients.find(ai => ai.name === ingDetails.name);
                            if (ingredientBase) {
                                const newItem = {
                                    name: ingDetails.name,
                                    weight: parseFloat(ingDetails.weight) || 0,
                                    originalData: ingredientBase
                                };
                                newItem.calculatedMacros = calculateSingleIngredientMacros(newItem.originalData, newItem.weight);
                                currentMeal.push(newItem);
                            } else {
                                console.warn(`Ingredient "${ingDetails.name}" from reused meal not found in available ingredients. Skipping.`);
                            }
                        });
                    }
                    renderCurrentMeal(); // Display the reused meal
                    if(currentMeal.length > 0) saveAndLogMealBtn.disabled = false; // Use renamed variable

                } catch (error) {
                    console.error("Error processing reused meal data:", error);
                } finally {
                    localStorage.removeItem('reuseMealTemplate'); // Clean up
                }
            }
        });

        // --- Meal History Functions (specific for track_meal.html to avoid conflicts if scripts were global) ---
        // TODO in later steps: Implement modal for "View Full Details" for history items
        // TODO in later steps: Implement "Reuse as Template" functionality for history items
        // TODO in later steps: Implement "Delete Meal" with confirmation for history items

        function displayMealHistoryOnTrackPage(historyItems) {
            const listElement = document.getElementById('mealHistoryListOnTrackPage');
            // const statusElement = document.getElementById('mealHistoryStatusOnTrackPage'); // Defined below if needed
            listElement.innerHTML = '';

            if (!historyItems || historyItems.length === 0) {
                listElement.innerHTML = '<li>No meal history found.</li>';
                return;
            }

            historyItems.forEach(meal => {
                const listItem = document.createElement('li');
                listItem.classList.add('meal-history-item'); // Use same class as index.html for consistent styling
                listItem.dataset.mealId = meal.id;

                let formattedTimestamp = 'Date unknown';
                if (meal.timestamp) {
                    try {
                        formattedTimestamp = new Date(meal.timestamp).toLocaleDateString(undefined, {
                            year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                        });
                    } catch (e) { console.warn("Could not parse timestamp:", meal.timestamp); }
                }

                const mainContent = document.createElement('div');
                mainContent.classList.add('meal-history-main');
                mainContent.innerHTML = `
                    <div class="meal-history-line1">
                        <strong class="meal-name">${meal.name || 'Unnamed Meal'}</strong>
                        <span class="meal-timestamp">Saved: ${formattedTimestamp}</span>
                    </div>
                    <div class="meal-history-line2 meal-preview">
                        <span>kcal: ${meal.total_calories ? meal.total_calories.toFixed(0) : 'N/A'}</span>
                        <span>Prot: ${meal.total_protein_g ? meal.total_protein_g.toFixed(1) : 'N/A'}g</span>
                        <span>Carb: ${meal.total_carbs_g ? meal.total_carbs_g.toFixed(1) : 'N/A'}g</span>
                        <span>Fat: ${meal.total_fat_g ? meal.total_fat_g.toFixed(1) : 'N/A'}g</span>
                    </div>
                `;
                listItem.appendChild(mainContent);

                const actionsButton = document.createElement('button');
                actionsButton.classList.add('meal-actions-btn');
                actionsButton.innerHTML = '&#8942;';
                actionsButton.title = 'Meal Actions';
                actionsButton.onclick = (event) => { // Corrected: Call the new actions menu function
                    event.stopPropagation();
                    showMealActionsMenuOnTrackPage(event.target, meal.id, meal.name);
                };
                listItem.appendChild(actionsButton);
                listElement.appendChild(listItem);
            });
        }

        async function fetchMealHistoryForTrackPage() {
            const statusElement = document.getElementById('mealHistoryStatusOnTrackPage');
            try {
                const response = await fetch('/api/get_meal_history');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.success && data.history) {
                    displayMealHistoryOnTrackPage(data.history);
                    if(statusElement) statusElement.textContent = '';
                } else {
                    throw new Error(data.message || 'Failed to parse meal history.');
                }
            } catch (error) {
                console.error('Error fetching meal history for track page:', error);
                document.getElementById('mealHistoryListOnTrackPage').innerHTML = '<li>Error loading meal history.</li>';
                if(statusElement) {
                    statusElement.textContent = `Error: ${error.message}`;
                    statusElement.className = 'status-message error';
                }
            }
        }
        // --- End Meal History Functions ---

        // Modal elements for Track Page
        const mealDetailModalTrackPage = document.getElementById('mealDetailModalTrackPage');
        const modalMealNameTrackPage = document.getElementById('modalMealNameTrackPage');
        const modalMealTimestampTrackPage = document.getElementById('modalMealTimestampTrackPage');
        const modalIngredientsListTrackPage = document.getElementById('modalIngredientsListTrackPage');
        const modalTotalNutritionTrackPage = document.getElementById('modalTotalNutritionTrackPage');
        const modalPer100gNutritionTrackPage = document.getElementById('modalPer100gNutritionTrackPage');

        function closeMealDetailModalTrackPage() {
            if(mealDetailModalTrackPage) mealDetailModalTrackPage.style.display = "none";
        }
        // Close modal if user clicks outside of the modal content (specific to this page's modal)
        window.addEventListener('click', function(event) {
            if (event.target == mealDetailModalTrackPage) {
                closeMealDetailModalTrackPage();
            }
        });

        async function showMealDetailsTrackPage(mealId) {
            try {
                const response = await fetch(`/api/get_meal_detail/${mealId}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (data.success && data.meal) {
                    const meal = data.meal;
                    modalMealNameTrackPage.textContent = meal.name || 'Unnamed Meal';
                    let ts = 'Date unknown';
                    if(meal.timestamp) try { ts = new Date(meal.timestamp).toLocaleString(); } catch(e){}
                    modalMealTimestampTrackPage.textContent = `Saved: ${ts}`;
                    modalIngredientsListTrackPage.innerHTML = meal.ingredients_used.map(ing => `<li><strong>${ing.name}:</strong> ${ing.weight_g}g</li>`).join('');
                    const tn = meal.total_nutrition;
                    modalTotalNutritionTrackPage.innerHTML = `
                        <li><strong>Total Calories:</strong> ${tn.total_calories !== undefined ? tn.total_calories.toFixed(0) : 'N/A'} kcal</li>
                        <li><strong>Total Protein:</strong> ${tn.total_protein_g !== undefined ? tn.total_protein_g.toFixed(1) : 'N/A'} g</li>
                        <li><strong>Total Carbs:</strong> ${tn.total_carbs_g !== undefined ? tn.total_carbs_g.toFixed(1) : 'N/A'} g</li>
                        <li><strong>Total Fat:</strong> ${tn.total_fat_g !== undefined ? tn.total_fat_g.toFixed(1) : 'N/A'} g</li>
                        <li><strong>Total Weight:</strong> ${tn.total_weight_g !== undefined ? tn.total_weight_g.toFixed(1) : 'N/A'} g</li>`;
                    const p100 = meal.nutrition_per_100g;
                    if (p100.calories_per_100g !== null && p100.calories_per_100g !== undefined) {
                        modalPer100gNutritionTrackPage.innerHTML = `
                            <li><strong>Calories:</strong> ${p100.calories_per_100g.toFixed(0)} kcal</li>
                            <li><strong>Protein:</strong> ${p100.protein_per_100g.toFixed(1)} g</li>
                            <li><strong>Carbs:</strong> ${p100.carbs_per_100g.toFixed(1)} g</li>
                            <li><strong>Fat:</strong> ${p100.fat_per_100g.toFixed(1)} g</li>`;
                    } else {
                        modalPer100gNutritionTrackPage.innerHTML = '<li>N/A (meal weight might be zero)</li>';
                    }
                    if(mealDetailModalTrackPage) mealDetailModalTrackPage.style.display = "block";
                } else { alert(data.message || 'Could not fetch meal details.'); }
            } catch (error) { console.error('Error fetching meal details:', error); alert('Error fetching meal details.'); }
        }

        function showMealActionsMenuOnTrackPage(buttonElement, mealId, mealName) {
            const existingMenu = document.getElementById('dynamicMealActionsMenuTrackPage');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.id = 'dynamicMealActionsMenuTrackPage';
            menu.classList.add('meal-actions-menu'); // Reuse CSS

            const viewBtn = document.createElement('button');
            viewBtn.textContent = 'View Details';
            viewBtn.onclick = () => { showMealDetailsTrackPage(mealId); menu.remove(); };
            menu.appendChild(viewBtn);

            const reuseBtn = document.createElement('button');
            reuseBtn.textContent = 'Reuse as Template';
            reuseBtn.onclick = async () => {
                menu.remove();
                try {
                    const response = await fetch(`/api/get_meal_detail/${mealId}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    if (data.success && data.meal) {
                        mealNameInput.value = data.meal.name || 'My Custom Meal (Reused)';
                        currentMeal = []; // Clear current meal
                        if (data.meal.ingredients_used && Array.isArray(data.meal.ingredients_used)) {
                            data.meal.ingredients_used.forEach(ingDetails => {
                                const ingredientBase = availableIngredients.find(ai => ai.name === ingDetails.name);
                                if (ingredientBase) {
                                    const newItem = {
                                        name: ingDetails.name,
                                        weight: parseFloat(ingDetails.weight_g) || 0,
                                        originalData: ingredientBase
                                    };
                                    newItem.calculatedMacros = calculateSingleIngredientMacros(newItem.originalData, newItem.weight);
                                    currentMeal.push(newItem);
                                } else { console.warn(`Ingredient "${ingDetails.name}" from reused meal not found. Skipping.`); }
                            });
                        }
                        renderCurrentMeal();
                        updateClientSideTotalPreview(); // Also update preview when reusing
                        if(currentMeal.length > 0) saveAndLogMealBtn.disabled = false; // Use renamed variable
                        // Scroll to top of meal composition section might be nice
                        document.getElementById('mealCompositionSection').scrollIntoView({ behavior: 'smooth' });
                    } else { alert(data.message || 'Could not fetch meal details for reuse.'); }
                } catch (error) { console.error('Error reusing meal:', error); alert('Error preparing meal for reuse.'); }
            };
            menu.appendChild(reuseBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete Meal';
            deleteBtn.classList.add('delete-action');
            deleteBtn.onclick = async () => {
                menu.remove();
                if (confirm(`Are you sure you want to delete the meal "${mealName}"? This action cannot be undone.`)) {
                    try {
                        const response = await fetch(`/api/delete_meal/${mealId}`, { method: 'DELETE' });
                        const result = await response.json();
                        if (response.ok && result.success) {
                            alert(result.message || 'Meal deleted successfully.');
                            fetchMealHistoryForTrackPage(); // Refresh this page's history list
                        } else { alert(result.message || 'Failed to delete meal.'); }
                    } catch (error) { console.error('Error deleting meal:', error); alert('An error occurred.'); }
                }
            };
            menu.appendChild(deleteBtn);

            document.body.appendChild(menu);
            const btnRect = buttonElement.getBoundingClientRect();
            menu.style.top = `${btnRect.bottom + window.scrollY}px`;
            menu.style.left = `${btnRect.left + window.scrollX - menu.offsetWidth + btnRect.width}px`;
            menu.style.display = 'block';

            const closeMenuHandlerTrackPage = (event) => {
                if (!menu.contains(event.target) && event.target !== buttonElement) {
                    menu.remove();
                    document.removeEventListener('click', closeMenuHandlerTrackPage, true);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenuHandlerTrackPage, true), 0);
        }
        // Need to update displayMealHistoryOnTrackPage to use showMealActionsMenuOnTrackPage
        // This was missed in previous step.
        // Correcting it here:
        // Original displayMealHistoryOnTrackPage actionsButton.onclick:
        // actionsButton.onclick = (event) => {
        //     event.stopPropagation();
        //     console.log(`TrackPage Actions for meal ID: ${meal.id} (Name: ${meal.name})`);
        //     alert(`TrackPage Actions for: ${meal.name}\n- View Details (TODO)\n- Reuse as Template (TODO)\n- Delete (TODO)`);
        // };
        // This will be updated in the next diff for displayMealHistoryOnTrackPage.

        // Global Shutdown server button event listener (keep existing)
        const globalShutdownBtn = document.getElementById('globalShutdownBtn');
        if (globalShutdownBtn) {
            globalShutdownBtn.addEventListener('click', async function() {
                try {
                    await fetch('/shutdown-server');
                    globalShutdownBtn.innerHTML = "&check;";
                    globalShutdownBtn.title = "Server shutting down";
                    globalShutdownBtn.disabled = true;
                    // Display a message on the page
                    let msgDiv = document.createElement('div');
                    msgDiv.style.position = 'fixed';
                    msgDiv.style.top = '50%';
                    msgDiv.style.left = '50%';
                    msgDiv.style.transform = 'translate(-50%, -50%)';
                    msgDiv.style.padding = '20px';
                    msgDiv.style.backgroundColor = 'lightgreen';
                    msgDiv.style.border = '1px solid green';
                    msgDiv.style.borderRadius = '5px';
                    msgDiv.style.zIndex = '1001';
                    msgDiv.textContent = 'Server shutdown initiated. You may close this window.';
                    document.body.appendChild(msgDiv);
                } catch (error) {
                    console.error('Error sending shutdown command:', error);
                    alert('Failed to send shutdown command. The server might already be down or unreachable.');
                }
            });
        }
    </script>
</body>
</html>
